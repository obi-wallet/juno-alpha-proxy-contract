/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.20.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { CanSpendResponse, ExecuteMsg, CosmosMsgForEmpty, BankMsg, Uint128, StakingMsg, DistributionMsg, WasmMsg, Binary, Addr, PeriodType, Coin, Empty, HotWalletParams, Authorizations, Authorization, CoinLimit, HotWalletsResponse, InstantiateMsg, MigrateMsg, OwnerResponse, QueryMsg, SignersResponse, Signer, UpdateDelayResponse } from "./ObiProxy.types";
export interface ObiProxyReadOnlyInterface {
  contractAddress: string;
  owner: () => Promise<OwnerResponse>;
  pending: () => Promise<PendingResponse>;
  signers: () => Promise<SignersResponse>;
  canExecute: ({
    msg,
    sender
  }: {
    msg: CosmosMsgForEmpty;
    sender: string;
  }) => Promise<CanExecuteResponse>;
  hotWallets: () => Promise<HotWalletsResponse>;
  canSpend: ({
    msgs,
    sender
  }: {
    msgs: CosmosMsgForEmpty[];
    sender: string;
  }) => Promise<CanSpendResponse>;
  updateDelay: () => Promise<UpdateDelayResponse>;
}
export class ObiProxyQueryClient implements ObiProxyReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.owner = this.owner.bind(this);
    this.pending = this.pending.bind(this);
    this.signers = this.signers.bind(this);
    this.canExecute = this.canExecute.bind(this);
    this.hotWallets = this.hotWallets.bind(this);
    this.canSpend = this.canSpend.bind(this);
    this.updateDelay = this.updateDelay.bind(this);
  }

  owner = async (): Promise<OwnerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      owner: {}
    });
  };
  pending = async (): Promise<PendingResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pending: {}
    });
  };
  signers = async (): Promise<SignersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      signers: {}
    });
  };
  canExecute = async ({
    msg,
    sender
  }: {
    msg: CosmosMsgForEmpty;
    sender: string;
  }): Promise<CanExecuteResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      can_execute: {
        msg,
        sender
      }
    });
  };
  hotWallets = async (): Promise<HotWalletsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      hot_wallets: {}
    });
  };
  canSpend = async ({
    msgs,
    sender
  }: {
    msgs: CosmosMsgForEmpty[];
    sender: string;
  }): Promise<CanSpendResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      can_spend: {
        msgs,
        sender
      }
    });
  };
  updateDelay = async (): Promise<UpdateDelayResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      update_delay: {}
    });
  };
}
export interface ObiProxyInterface extends ObiProxyReadOnlyInterface {
  contractAddress: string;
  sender: string;
  execute: ({
    msgs
  }: {
    msgs: CosmosMsgForEmpty[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  simExecute: ({
    msgs
  }: {
    msgs: CosmosMsgForEmpty[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  proposeUpdateOwner: ({
    newOwner
  }: {
    newOwner: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  confirmUpdateOwner: ({
    signerTypes,
    signers
  }: {
    signerTypes: string[];
    signers: string[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  cancelUpdateOwner: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  addHotWallet: ({
    newHotWallet
  }: {
    newHotWallet: HotWalletParams;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  rmHotWallet: ({
    doomedHotWallet
  }: {
    doomedHotWallet: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateHotWalletSpendLimit: ({
    hotWallet,
    newSpendLimits
  }: {
    hotWallet: string;
    newSpendLimits: CoinLimit;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateUpdateDelay: ({
    hours
  }: {
    hours: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class ObiProxyClient extends ObiProxyQueryClient implements ObiProxyInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.execute = this.execute.bind(this);
    this.simExecute = this.simExecute.bind(this);
    this.proposeUpdateOwner = this.proposeUpdateOwner.bind(this);
    this.confirmUpdateOwner = this.confirmUpdateOwner.bind(this);
    this.cancelUpdateOwner = this.cancelUpdateOwner.bind(this);
    this.addHotWallet = this.addHotWallet.bind(this);
    this.rmHotWallet = this.rmHotWallet.bind(this);
    this.updateHotWalletSpendLimit = this.updateHotWalletSpendLimit.bind(this);
    this.updateUpdateDelay = this.updateUpdateDelay.bind(this);
  }

  execute = async ({
    msgs
  }: {
    msgs: CosmosMsgForEmpty[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      execute: {
        msgs
      }
    }, fee, memo, funds);
  };
  simExecute = async ({
    msgs
  }: {
    msgs: CosmosMsgForEmpty[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      sim_execute: {
        msgs
      }
    }, fee, memo, funds);
  };
  proposeUpdateOwner = async ({
    newOwner
  }: {
    newOwner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      propose_update_owner: {
        new_owner: newOwner
      }
    }, fee, memo, funds);
  };
  confirmUpdateOwner = async ({
    signerTypes,
    signers
  }: {
    signerTypes: string[];
    signers: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      confirm_update_owner: {
        signer_types: signerTypes,
        signers
      }
    }, fee, memo, funds);
  };
  cancelUpdateOwner = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      cancel_update_owner: {}
    }, fee, memo, funds);
  };
  addHotWallet = async ({
    newHotWallet
  }: {
    newHotWallet: HotWalletParams;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_hot_wallet: {
        new_hot_wallet: newHotWallet
      }
    }, fee, memo, funds);
  };
  rmHotWallet = async ({
    doomedHotWallet
  }: {
    doomedHotWallet: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      rm_hot_wallet: {
        doomed_hot_wallet: doomedHotWallet
      }
    }, fee, memo, funds);
  };
  updateHotWalletSpendLimit = async ({
    hotWallet,
    newSpendLimits
  }: {
    hotWallet: string;
    newSpendLimits: CoinLimit;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_hot_wallet_spend_limit: {
        hot_wallet: hotWallet,
        new_spend_limits: newSpendLimits
      }
    }, fee, memo, funds);
  };
  updateUpdateDelay = async ({
    hours
  }: {
    hours: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_update_delay: {
        hours
      }
    }, fee, memo, funds);
  };
}