/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.10.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { AdminResponse, ExecuteMsg, CosmosMsgForEmpty, BankMsg, Uint128, StakingMsg, DistributionMsg, WasmMsg, Binary, Addr, Timestamp, Uint64, PeriodType, Coin, Empty, HotWallet, CoinLimit, HotWalletsResponse, InstantiateMsg, MigrateMsg, QueryMsg } from "./ObiProxy.types";
export interface ObiProxyReadOnlyInterface {
  contractAddress: string;
  admin: () => Promise<AdminResponse>;
  canExecute: ({
    msg,
    sender
  }: {
    msg: CosmosMsgForEmpty;
    sender: string;
  }) => Promise<CanExecuteResponse>;
  hotWallets: () => Promise<HotWalletsResponse>;
}
export class ObiProxyQueryClient implements ObiProxyReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.admin = this.admin.bind(this);
    this.canExecute = this.canExecute.bind(this);
    this.hotWallets = this.hotWallets.bind(this);
  }

  admin = async (): Promise<AdminResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      admin: {}
    });
  };
  canExecute = async ({
    msg,
    sender
  }: {
    msg: CosmosMsgForEmpty;
    sender: string;
  }): Promise<CanExecuteResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      can_execute: {
        msg,
        sender
      }
    });
  };
  hotWallets = async (): Promise<HotWalletsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      hot_wallets: {}
    });
  };
}
export interface ObiProxyInterface extends ObiProxyReadOnlyInterface {
  contractAddress: string;
  sender: string;
  execute: ({
    msgs
  }: {
    msgs: CosmosMsgForEmpty[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  proposeUpdateAdmin: ({
    newAdmin
  }: {
    newAdmin: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  confirmUpdateAdmin: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  addHotWallet: ({
    newHotWallet
  }: {
    newHotWallet: HotWallet;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  rmHotWallet: ({
    doomedHotWallet
  }: {
    doomedHotWallet: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class ObiProxyClient extends ObiProxyQueryClient implements ObiProxyInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.execute = this.execute.bind(this);
    this.proposeUpdateAdmin = this.proposeUpdateAdmin.bind(this);
    this.confirmUpdateAdmin = this.confirmUpdateAdmin.bind(this);
    this.addHotWallet = this.addHotWallet.bind(this);
    this.rmHotWallet = this.rmHotWallet.bind(this);
  }

  execute = async ({
    msgs
  }: {
    msgs: CosmosMsgForEmpty[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      execute: {
        msgs
      }
    }, fee, memo, funds);
  };
  proposeUpdateAdmin = async ({
    newAdmin
  }: {
    newAdmin: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      propose_update_admin: {
        new_admin: newAdmin
      }
    }, fee, memo, funds);
  };
  confirmUpdateAdmin = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      confirm_update_admin: {}
    }, fee, memo, funds);
  };
  addHotWallet = async ({
    newHotWallet
  }: {
    newHotWallet: HotWallet;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_hot_wallet: {
        new_hot_wallet: newHotWallet
      }
    }, fee, memo, funds);
  };
  rmHotWallet = async ({
    doomedHotWallet
  }: {
    doomedHotWallet: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      rm_hot_wallet: {
        doomed_hot_wallet: doomedHotWallet
      }
    }, fee, memo, funds);
  };
}